<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Historial | RecargasPaCuba</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <meta name="color-scheme" content="light">
  <meta name="theme-color" content="#28c6db">
  <link rel="stylesheet" href="styles/base.css?v=r1">
  <link rel="stylesheet" href="styles/app.css?v=r1">
  <script src="js/ui.js?v=r1"></script>
  <script type="module">
  import { guardProtectedPage } from "./js/guard.js?v=r1";
  import { auth, onAuthStateChanged } from "./js/firebase.js?v=r1";
  window.guardProtectedPage = guardProtectedPage;
  window.auth = auth;
  window.onAuthStateChanged = onAuthStateChanged;
</script>
  <style>
    /* Tipografía como Cuenta/Recargar */
    @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700;800&display=swap');

    /* Anti-flash align with recargar */
    html { visibility: hidden; }
    html.loaded { visibility: visible; }

    /* Anti-flash (Historial): no muestres las cards hasta data-ready */
    html:not(.rpc-ready) .historial-container { opacity: 0 !important; pointer-events: none; }
    html.rpc-ready .historial-container { opacity: 1 !important; }

    :root{
      --left:#0b63d1;
      --right:#19c6c3;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      margin: 0;
      font-family: 'Poppins', system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      color: white;
      padding-bottom: 90px;
    }

    .historial-container {
      flex: 1;
      padding: 20px 16px 10px;
      max-width: 520px;
      margin: 0 auto;
    }

    .icono {
      min-width: 46px;
      min-height: 46px;
      border-radius: 16px;
      background: rgba(15, 23, 42, 0.75);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 22px;
      box-shadow: 0 12px 26px rgba(0,0,0,0.45);
      position: relative;
      z-index: 1;
    }

    .contenido {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 2px;
      position: relative;
      z-index: 1;
    }

    .titulo {
      font-size: 16px;
      font-weight: 700;
    }

    .descripcion {
      font-size: 13px;
      opacity: 0.92;
      margin-top: 2px;
    }

    .fecha {
      font-size: 12px;
      opacity: 0.78;
      margin-top: 4px;
    }

    .estado {
      font-size: 12px;
      font-weight: 700;
      padding: 7px 12px;
      border-radius: 999px;
      white-space: nowrap;
      border: 1px solid rgba(15,23,42,0.28);
      box-shadow: 0 10px 22px rgba(0,0,0,0.40);
      position: relative;
      z-index: 1;
    }

    .verde    { background: #3ddc97; color: #022c22; }
    .azul     { background: #4bbcff; color: #082f49; }
    .rojo     { background: #ff6b6b; color: #450a0a; }
    .amarillo { background: #ffd966; color:#422006; }

    /* MODAL */
    .modal-bg {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.55);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 3000;
      backdrop-filter: blur(6px);
      padding: 20px 14px;
    }

    .modal {
      background: radial-gradient(circle at top left, rgba(56, 189, 248, 0.16), transparent 55%),
                  rgba(15, 23, 42, 0.96);
      padding: 20px 18px 18px;
      border-radius: 20px;
      max-width: 420px;
      width: 100%;
      border: 1px solid rgba(148, 163, 184, 0.7);
      box-shadow: 0 18px 35px rgba(0,0,0,0.55);
      color: #fff;
    }

    .modal h3 {
      margin: 0 0 12px;
      text-align: center;
      font-size: 16px;
      font-weight: 700;
    }

    .modal-item {
      font-size: 13px;
      padding: 8px 0;
      border-bottom: 1px solid rgba(148,163,184,0.45);
    }

    .modal-item:last-child {
      border-bottom: none;
    }

    .cerrar {
      margin-top: 14px;
      width: 100%;
      padding: 10px;
      border-radius: 12px;
      border: none;
      font-weight: 700;
      background: #ffb13b;
      color: #2c1200;
      cursor: pointer;
      box-shadow: 0 10px 24px rgba(0,0,0,0.40);
      font-size: 14px;
    }
  </style>
</head>

<body>

  <div class="historial-container" style="opacity:0; pointer-events:none;">

    <div class="card card--gradient" id="card-recarga" role="button" tabindex="0" aria-label="Ver historial de recargas">
      <div class="icono">⚡</div>
      <div class="contenido">
        <div class="titulo">Recarga realizada</div>
        <div class="descripcion" id="recarga-desc">Aún no tienes movimientos</div>
        <div class="fecha" id="recarga-fecha"></div>
      </div>
      <div class="estado verde" id="recarga-estado">Sin movimientos</div>
    </div>

    <!-- Manual-beta: tarjeta "Saldo agregado" eliminada -->

    <div class="card card--gradient" id="card-correo" role="button" tabindex="0" aria-label="Ver historial de correos">
      <div class="icono">📧</div>
      <div class="contenido">
        <div class="titulo">Correo recibido</div>
        <div class="descripcion" id="correo-desc">Aún no tienes movimientos</div>
        <div class="fecha" id="correo-fecha"></div>
      </div>
      <div class="estado azul" id="correo-estado">Sin movimientos</div>
    </div>
 
  </div>
 
  <!-- MODAL -->
  <div class="modal-bg" id="modal-bg">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="modal-titulo" tabindex="-1">
      <h3 id="modal-titulo"></h3>
      <div id="modal-lista"></div>
      <button class="cerrar" id="cerrarModal" type="button" aria-label="Cerrar">Cerrar</button>
    </div>
  </div>
 
  <!-- Barra inferior unificada -->
  <nav class="app-nav">
    <div class="nav-inner">
      <a href="recargar.html" class="nav-btn">
        <span>⚡</span>
        <div>Recargar</div>
      </a>
      <a href="historial.html" class="nav-btn active">
        <span>🕑</span>
        <div>Historial</div>
      </a>
      <a href="cuenta.html" class="nav-btn">
        <span>👤</span>
        <div>Cuenta</div>
      </a>
    </div>
  </nav>

  <!-- Catálogo de productos (para resolver productId -> importe) -->
  <script src="js/products.js?v=r1"></script>

  <!-- Capa de datos unificada -->
  <script src="js/userData.js?v=r1"></script>

  <script>
    window.addEventListener("DOMContentLoaded", () => {
      try { document.documentElement.classList.add("loaded"); } catch (_) {}

      if (typeof guardProtectedPage === "function") {
        guardProtectedPage({
          redirectTo: "index.html",
          timeoutMs: 20000,
          auth,
          onAuthStateChanged,
          onReady: (user) => {
            try {
              window.__rpcAuthReady = true;
              window.__rpcAuthUser = user || null;
              window.dispatchEvent(new Event("rpc-auth-ready"));
            } catch (_) {}
          },
        });
      }
    });

    window.addEventListener("load", () => {
      try { document.documentElement.classList.add("loaded"); } catch (_) {}

      const emailUsuarioBase = (localStorage.getItem("usuario") || "").toString();
      let sessionEmailSnapshot = (localStorage.getItem("usuario") || emailUsuarioBase || "").toString();

      function getManualBetaOrdersLog() {
        try {
          const raw = localStorage.getItem("rpc_mb_orders_log") || "[]";
          const arr = JSON.parse(raw);
          const list = Array.isArray(arr) ? arr : [];

          const out = [];
          const seen = new Set();

          function idToMs(orderId) {
            try {
              const s = String(orderId || "").trim();
              const m = s.match(/^MB-(\d{10,})-/i);
              if (!m) return 0;
              const n = Number(m[1]);
              if (!Number.isFinite(n)) return 0;
              // si viene en segundos, conviértelo; si viene en ms, déjalo
              return (n < 1e12) ? (n * 1000) : n;
            } catch (_) {
              return 0;
            }
          }

          function mapOne(o) {
            const oid = String((o && (o.orderId || o.orderID || o.id)) || "").trim();
            if (!oid || seen.has(oid)) return null;
            seen.add(oid);

            const destino = String((o && (o.destino || o.destination || o.numero || o.to)) || "").trim();

            const productIdRaw = (o && (o.productId || o.product || o.offerId || o.itemId)) || "";
            const productIdNorm = String(productIdRaw || "").trim().toLowerCase();

            let amountRaw = (o && (o.amount ?? o.importe ?? o.price ?? o.total ?? o.precio)) ?? undefined;
            let importeNum = undefined;
            if (amountRaw !== undefined && amountRaw !== null && amountRaw !== "") {
              const n = Number(String(amountRaw).replace(",", "."));
              if (!isNaN(n)) importeNum = n;
            }

            const createdAtMs =
              Number((o && o.createdAtMs) || 0) ||
              idToMs(oid) ||
              0;

            const fecha = String((o && (o.fecha || o.createdAt)) || "").trim();

            return {
              tipo: "recarga",
              id: oid,
              orderId: oid,
              numero: destino,
              productId: productIdNorm,
              importe: importeNum,
              createdAtMs: createdAtMs,
              fecha: fecha,
              status: (o && (o.status || o.clientStatus)) ? String(o.status || o.clientStatus) : "",
              estado: "",
              extra: {
                paymentMethod: String((o && (o.paymentMethod || o.method)) || "").trim(),
                paymentLink: String((o && (o.paymentLink || o.payment_link || o.link)) || "").trim(),
                clientStatus: String((o && o.clientStatus) || "").trim(),
                productName: String((o && (o.productName || o.offerName || o.title)) || "").trim()
              }
            };
          }

          // 1) last_order primero (si existe)
          try {
            const lastRaw = localStorage.getItem("rpc_mb_last_order") || "";
            if (lastRaw) {
              const lastObj = JSON.parse(lastRaw);
              const mapped = mapOne(lastObj);
              if (mapped) out.push(mapped);
            }
          } catch (_) {}

          // 2) log completo
          for (let i = 0; i < list.length; i++) {
            const mapped = mapOne(list[i]);
            if (mapped) out.push(mapped);
          }

          return out.slice(0, 120);
        } catch (e) {
          console.error("Error leyendo rpc_mb_orders_log / rpc_mb_last_order:", e);
          return [];
        }
      }

      (async () => {
        let lista = getManualBetaOrdersLog();

        // Espera a auth-ready para evitar renders pre-auth (failsafe timeout).
        try {
          if (!window.__rpcAuthReady) {
            await new Promise((resolve) => {
              const t = setTimeout(resolve, 20000);
              window.addEventListener("rpc-auth-ready", () => { clearTimeout(t); resolve(); }, { once: true });
            });
          }
          if (window.__rpcAuthUser && window.__rpcAuthUser.email) {
            sessionEmailSnapshot = String(window.__rpcAuthUser.email).toLowerCase();
          }
        } catch (_) {}

        let __historialRevealed = false;
        function revealHistorialOnce() {
          if (__historialRevealed) return;
          __historialRevealed = true;
          document.documentElement.classList.add("rpc-ready");
          try {
            const hc = document.querySelector(".historial-container");
            if (hc) { hc.style.opacity = "1"; hc.style.pointerEvents = "auto"; }
          } catch (_) {}
        }

        // Failsafe: si algo rompe antes del reveal, no dejes la pantalla en azul para siempre.
        setTimeout(() => {
          try { revealHistorialOnce(); } catch (_) {}
        }, 3000);

        // ===== Orden/fecha estables (local + Firestore) =====
        function msFromPendId(id) {
          try {
            const s = (id || "").toString().trim();
            const m = s.match(/^PEND-(\d{10,})$/i);
            if (!m) return 0;
            const n = Number(m[1]);
            return Number.isFinite(n) ? n : 0;
          } catch (_) {
            return 0;
          }
        }

        function parseEsFechaToMs(str) {
          try {
            const s = (str || "").toString().trim();
            const m = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})(?:,)?\s*(\d{1,2}):(\d{2})(?::(\d{2}))?/);
            if (!m) return 0;
            const dd = Number(m[1]);
            const mm = Number(m[2]);
            const yy = Number(m[3]);
            const hh = Number(m[4]);
            const mi = Number(m[5]);
            const ss = Number(m[6] || 0);
            const d = new Date(yy, (mm - 1), dd, hh, mi, ss);
            const t = d.getTime();
            return isNaN(t) ? 0 : t;
          } catch (_) {
            return 0;
          }
        }

        function parseAnyFechaToMs(str) {
          try {
            const s = (str || "").toString().trim();
            if (!s) return 0;
            const es = parseEsFechaToMs(s);
            if (es) return es;
            const iso = Date.parse(s);
            return isNaN(iso) ? 0 : iso;
          } catch (_) {
            return 0;
          }
        }

        function sortKeyMovimiento(m) {
          if (!m) return 0;

          const ca = Number(m.createdAtMs || 0);
          if (ca > 0) return ca;

          const pend = msFromPendId(m.id);
          if (pend > 0) return pend;

          const f = (m.fecha || "").toString().trim();
          const ms = parseAnyFechaToMs(f);
          return ms || 0;
        }

        function normalizeFechaText(m) {
          if (!m) return "";
          const raw = (m.fecha || "").toString().trim();
          if (/^\d{1,2}\/\d{1,2}\/\d{4}/.test(raw)) return raw;
          const ms = sortKeyMovimiento(m);
          if (ms > 0) {
            try { return new Date(ms).toLocaleString("es-ES"); } catch (_) { return ""; }
          }
          return raw || "";
        }

        // ===== Helpers DOM =====
        function safeSetText(el, txt) {
          try {
            if (!el) return;
            const t = (txt == null) ? "" : String(txt);
            if (el.textContent !== t) el.textContent = t;
          } catch (_) {}
        }

        function safeSetClass(el, cls) {
          try {
            if (!el) return;
            const c = (cls == null) ? "" : String(cls);
            if (el.className !== c) el.className = c;
          } catch (_) {}
        }

        // ===== Selección estable por ID =====
        let selectedRecargaId = null;
        let __lastRecargaFingerprint = null;

        function fingerprintRecarga(u) {
          if (!u) return "";
          const id = (u.id || "").toString();
          const num = (u.numero || "").toString();
          const st = (u.status || "").toString();
          const est = (u.estado || "").toString();
          const imp = Number(u.importe);
          const impTxt = isNaN(imp) ? "" : imp.toFixed(2);
          const f = normalizeFechaText(u) || "";
          return `${id}|${num}|${st}|${est}|${impTxt}|${f}`;
        }

        function pickTopRecargaFromList(arr) {
          const recargas = (Array.isArray(arr) ? arr : []).filter(m => m && m.tipo === "recarga");
          if (!recargas.length) return null;
          recargas.sort((a, b) => (sortKeyMovimiento(b) - sortKeyMovimiento(a)));
          return recargas[0] || null;
        }

        function getSelectedRecarga(recargasSorted, allowChange) {
          if (!Array.isArray(recargasSorted) || !recargasSorted.length) return null;

          const top = recargasSorted[0] || null;
          if (!top) return null;

          const topId = (top.id || "").toString();
          if (!selectedRecargaId) {
            selectedRecargaId = topId;
            return top;
          }

          const found = recargasSorted.find(r => r && (r.id || "").toString() === selectedRecargaId) || null;
          if (found && !allowChange) return found;

          if (allowChange && topId && topId !== selectedRecargaId) {
            selectedRecargaId = topId;
            return top;
          }

          return found || top;
        }

        function updateRecargaAndCorreoAtomic(u) {
          const fp = fingerprintRecarga(u);
          if (fp && fp === __lastRecargaFingerprint) return;
          __lastRecargaFingerprint = fp;

          const descR   = document.getElementById("recarga-desc");
          const fechaR  = document.getElementById("recarga-fecha");
          const estadoR = document.getElementById("recarga-estado");

          const correoDesc   = document.getElementById("correo-desc");
          const correoFecha  = document.getElementById("correo-fecha");
          const correoEstado = document.getElementById("correo-estado");

          const importeR = Number(u && u.importe);
          const importeTxtR = isNaN(importeR) ? "" : `-${importeR.toFixed(2)} €`;

          const fechaTxt = normalizeFechaText(u);

          // Manual-beta UI: SOLO RECIBIDO / COMPLETADO (no mostrar estados legacy)
          let statusUp = (u && u.status ? u.status : "").toString().trim().toUpperCase();
          if (!statusUp) {
            const legacyUp = (u && u.estado ? u.estado : "").toString().trim().toUpperCase();
            statusUp = legacyUp || "";
          }

          const isCompleted =
            statusUp === "COMPLETED" ||
            statusUp === "COMPLETADO" ||
            statusUp === "OK" ||
            statusUp === "SUCCESS" ||
            statusUp === "DELIVERED" ||
            (((u && u.estado) ? String(u.estado).trim().toUpperCase() : "") === "OK");

          const uiState = isCompleted ? "COMPLETADO" : "RECIBIDO";
          const ui = isCompleted
            ? { text: "COMPLETADO", cls: "estado verde" }
            : { text: "RECIBIDO",   cls: "estado azul" };

          // Recarga realizada (mantén importe visible, status en la píldora)
          const recargaTituloEl = document.querySelector("#card-recarga .titulo");
          if (recargaTituloEl) {
            const t = (uiState === "COMPLETADO") ? "Recarga completada" : "Recarga recibida";
            safeSetText(recargaTituloEl, t);
          }

          const orderIdTxt = (u && (u.orderId || u.id)) ? String(u.orderId || u.id) : "";
          const numeroTxt = (u && u.numero) ? String(u.numero) : "";

          const metodoRaw =
            (u && (u.paymentMethod || (u.extra && u.extra.paymentMethod) || u.method))
              ? (u.paymentMethod || (u.extra && u.extra.paymentMethod) || u.method)
              : "";
          let metodoTxt = (metodoRaw == null) ? "" : String(metodoRaw).trim();
          if (metodoTxt) {
            const up = metodoTxt.toUpperCase();
            if (up === "PAYPAL") metodoTxt = "PayPal";
            else if (up === "REVOLUT") metodoTxt = "Revolut";
            else if (up === "BIZUM") metodoTxt = "Bizum";
          }

          const ofertaRaw =
            (u && (u.productName || (u.extra && u.extra.productName)))
              ? (u.productName || (u.extra && u.extra.productName))
              : "";
          let ofertaTxt = (ofertaRaw == null) ? "" : String(ofertaRaw).trim();
          if (!ofertaTxt) ofertaTxt = (u && u.productId) ? String(u.productId).trim() : "";

          const partsDesc = [];
          if (ofertaTxt) partsDesc.push(ofertaTxt);
          if (metodoTxt) partsDesc.push(metodoTxt);
          if (numeroTxt) partsDesc.push(`Recarga a ${numeroTxt}`);
          if (importeTxtR) partsDesc.push(importeTxtR);
          if (orderIdTxt) partsDesc.push(`ID: ${orderIdTxt}`);

          const descTxt = partsDesc.length ? partsDesc.join(" | ") : "Aún no tienes movimientos";
          safeSetText(descR, descTxt);
          safeSetText(fechaR, fechaTxt);
          safeSetText(estadoR, ui.text);
          safeSetClass(estadoR, ui.cls);

          // Correo recibido (snapshot de email: NO cambies entre renders)
          const idTxt      = (u && (u.orderId || u.id)) ? String(u.orderId || u.id) : "Sin ID";
          const emailTxt   = (sessionEmailSnapshot || localStorage.getItem("usuario") || emailUsuarioBase || "Sin correo registrado").toString();
          const importeTxt = isNaN(importeR) ? "" : `${importeR.toFixed(2)} €`;
          const numeroTxtC = (u && u.numero) ? String(u.numero) : "";

          const partsCorreo = [];
          partsCorreo.push(emailTxt);
          if (metodoTxt) partsCorreo.push(metodoTxt);
          if (importeTxt) partsCorreo.push(importeTxt);
          if (numeroTxtC) partsCorreo.push(numeroTxtC);
          partsCorreo.push(`ID: ${idTxt}`);

          const correoDescTxt = partsCorreo.join(" | ");

          safeSetText(correoDesc, correoDescTxt);
          safeSetText(correoFecha, fechaTxt);
          // Manual-beta: el card de correo siempre es “Correo recibido”
const correoTituloEl = document.querySelector("#card-correo .titulo");
if (correoTituloEl) {
  safeSetText(correoTituloEl, "Correo recibido");
}


          safeSetText(correoEstado, ui.text);
          safeSetClass(correoEstado, ui.cls);
        }

        function renderCardsFromLista(allowSelectionChange) {
          const recargas = lista.filter(m => m && m.tipo === "recarga");
          recargas.sort((a, b) => (sortKeyMovimiento(b) - sortKeyMovimiento(a)));

          // Empty-state coherente (Manual-beta)
          if (!recargas.length) {
            try { selectedRecargaId = null; } catch (_) {}
            try { __lastRecargaFingerprint = null; } catch (_) {}

            const descR   = document.getElementById("recarga-desc");
            const fechaR  = document.getElementById("recarga-fecha");
            const estadoR = document.getElementById("recarga-estado");

            const correoDesc   = document.getElementById("correo-desc");
            const correoFecha  = document.getElementById("correo-fecha");
            const correoEstado = document.getElementById("correo-estado");

            const recargaTituloEl = document.querySelector("#card-recarga .titulo");
            if (recargaTituloEl) safeSetText(recargaTituloEl, "Recarga realizada");

            const correoTituloEl = document.querySelector("#card-correo .titulo");
            if (correoTituloEl) safeSetText(correoTituloEl, "Correo recibido");

            safeSetText(descR, "Aún no tienes movimientos");
            safeSetText(fechaR, "");
            safeSetText(estadoR, "Sin movimientos");
            safeSetClass(estadoR, "estado verde");

            safeSetText(correoDesc, "Aún no tienes movimientos");
            safeSetText(correoFecha, "");
            safeSetText(correoEstado, "Sin movimientos");
            safeSetClass(correoEstado, "estado azul");

            return;
          }

          const selectedRecarga = getSelectedRecarga(recargas, !!allowSelectionChange);
          if (selectedRecarga) {
            updateRecargaAndCorreoAtomic(selectedRecarga);
          }
        }

        async function getFirebaseUserOnce(timeoutMs) {
          return new Promise((resolve) => {
            try {
              if (auth && auth.currentUser) return resolve(auth.currentUser);

              let done = false;
              const t = setTimeout(() => {
                if (done) return;
                done = true;
                resolve(auth && auth.currentUser ? auth.currentUser : null);
              }, typeof timeoutMs === "number" ? timeoutMs : 8000);

              const unsub = onAuthStateChanged(auth, (user) => {
                if (done) return;
                done = true;
                clearTimeout(t);
                try { if (typeof unsub === "function") unsub(); } catch (_) {}
                resolve(user || null);
              });
            } catch (e) {
              resolve(null);
            }
          });
        }

        async function getFirebaseSdkVersionFromFirebaseJs() {
          try {
            const res = await fetch("./js/firebase.js?v=r1", { cache: "no-store" });
            if (!res.ok) return null;
            const text = await res.text();
            const m = text.match(/firebasejs\/(\d+\.\d+\.\d+)\//);
            return m ? m[1] : null;
          } catch (e) {
            return null;
          }
        }

        function toDateFromCreatedAt(value) {
          try {
            if (!value) return null;
            if (value instanceof Date) return value;
            if (typeof value === "string" || typeof value === "number") {
              const d = new Date(value);
              return isNaN(d.getTime()) ? null : d;
            }
            if (typeof value.toDate === "function") {
              const d = value.toDate();
              return d instanceof Date && !isNaN(d.getTime()) ? d : null;
            }
            if (typeof value.seconds === "number") {
              const d = new Date(value.seconds * 1000);
              return isNaN(d.getTime()) ? null : d;
            }
            return null;
          } catch (e) {
            return null;
          }
        }

        function formatFechaFromCreatedAt(value) {
          const d = toDateFromCreatedAt(value);
          if (!d) return "";
          try { return d.toLocaleString("es-ES"); } catch (e) { return ""; }
        }

        function mergeByIdPreferFirst(primary, secondary) {
          const out = [];
          const seen = new Set();

          (Array.isArray(primary) ? primary : []).forEach((m) => {
            const id = (m && m.id) ? String(m.id) : "";
            if (id && seen.has(id)) return;
            if (id) seen.add(id);
            out.push(m);
          });

          (Array.isArray(secondary) ? secondary : []).forEach((m) => {
            const id = (m && m.id) ? String(m.id) : "";
            if (id && seen.has(id)) return;
            if (id) seen.add(id);
            out.push(m);
          });

          return out;
        }

        async function fetchRecargasFromFirestore(uid) {
          const version = (await getFirebaseSdkVersionFromFirebaseJs()) || null;
          if (!version) return [];

          const mod = await import(`https://www.gstatic.com/firebasejs/${version}/firebase-firestore.js`);
          const { getFirestore, connectFirestoreEmulator, collection, query, where, orderBy, limit, getDocs } = mod;

          const db = getFirestore();
          try {
            const h = (location && location.hostname) ? location.hostname : "";
            if (h === "127.0.0.1" || h === "localhost") {
              connectFirestoreEmulator(db, "127.0.0.1", 8080);
            }
          } catch (_) {}

          const col = collection(db, "recargas");

          let docs = [];
          try {
            const q = query(col, where("uid", "==", uid), orderBy("createdAt", "desc"), limit(50));
            const snap = await getDocs(q);
            docs = snap && snap.docs ? snap.docs : [];
          } catch (err1) {
            try {
              const q2 = query(col, where("uid", "==", uid), limit(200));
              const snap2 = await getDocs(q2);
              docs = snap2 && snap2.docs ? snap2.docs : [];
            } catch (err2) {
              console.error("Error leyendo Firestore (recargas):", err2);
              return [];
            }
          }

          const mapped = docs.map((d) => {
            const data = (d && typeof d.data === "function") ? (d.data() || {}) : {};
            const statusRaw = (data.status || data.estado || "").toString();
            const statusUp = statusRaw ? statusRaw.toUpperCase() : "";

            // Status canónico para UI (PENDING/COMPLETED/FAILED/CANCELLED/REFUNDED)
            let canonicalStatus = statusUp;
            if (canonicalStatus === "OK" || canonicalStatus === "SUCCESS" || canonicalStatus === "PAID" || canonicalStatus === "DELIVERED") {
              canonicalStatus = "COMPLETED";
            } else if (canonicalStatus === "CANCELED") {
              canonicalStatus = "CANCELLED";
            }

            // Legacy (lo que ya usa tu UI actual)
            const estado = (canonicalStatus === "COMPLETED") ? "OK" : (canonicalStatus || "");

            const productIdRaw = (data.productId || data.product || "");
            const productIdNorm = String(productIdRaw || "").trim().toLowerCase();

            let importeRaw = (data.importe ?? data.amount ?? data.price ?? data.precio ?? data.valor);

            if ((importeRaw === undefined || importeRaw === null || importeRaw === "") && productIdNorm) {
              let found = null;
              if (window.Products && typeof window.Products.getById === "function") {
                try { found = window.Products.getById(productIdNorm); } catch (_) { found = null; }
              }
              if (found) {
                importeRaw = (found.importe ?? found.amount ?? found.price ?? found.precio ?? found.valor);
              }
            }

            let importeNum = undefined;
            if (importeRaw !== undefined && importeRaw !== null && importeRaw !== "") {
              const n = Number(String(importeRaw).replace(",", "."));
              if (!isNaN(n)) importeNum = n;
            }

            const createdAtMs = (toDateFromCreatedAt(data.createdAt)?.getTime() || msFromPendId(d && d.id));

            const orderIdResolved = String((data.orderId || data.orderID || data.id || (d && d.id) || "")).trim() || ((d && d.id) ? String(d.id) : "");

            return {
              tipo: "recarga",
              id: orderIdResolved,
              orderId: orderIdResolved,
              numero: data.destino || data.numero || "",
              productId: productIdNorm,
              importe: importeNum,
              createdAtMs: createdAtMs,
              fecha: formatFechaFromCreatedAt(data.createdAt),
              status: canonicalStatus,
              estado: estado
            };
          });

          mapped.sort((a, b) => (sortKeyMovimiento(b) - sortKeyMovimiento(a)));
          return mapped.slice(0, 50);
        }

        async function fetchOrdersFromFirestore(uid) {
          const version = (await getFirebaseSdkVersionFromFirebaseJs()) || null;
          if (!version) return [];

          const mod = await import(`https://www.gstatic.com/firebasejs/${version}/firebase-firestore.js`);
          const { getFirestore, connectFirestoreEmulator, collection, query, where, orderBy, limit, getDocs } = mod;

          const db = getFirestore();
          try {
            const h = (location && location.hostname) ? location.hostname : "";
            if (h === "127.0.0.1" || h === "localhost") {
              connectFirestoreEmulator(db, "127.0.0.1", 8080);
            }
          } catch (_) {}

          const col = collection(db, "orders");

          let docs = [];
          try {
            const q = query(col, where("uid", "==", uid), orderBy("createdAt", "desc"), limit(50));
            const snap = await getDocs(q);
            docs = snap && snap.docs ? snap.docs : [];
          } catch (err1) {
            try {
              const q2 = query(col, where("uid", "==", uid), limit(200));
              const snap2 = await getDocs(q2);
              docs = snap2 && snap2.docs ? snap2.docs : [];
            } catch (err2) {
              console.error("Error leyendo Firestore (orders):", err2);
              return [];
            }
          }

          const mapped = docs.map((d) => {
            const data = (d && typeof d.data === "function") ? (d.data() || {}) : {};

            const statusRaw = (data.status || data.estado || "").toString();
            let statusUp = statusRaw ? statusRaw.toUpperCase() : "";

            // Normaliza a los estados que tu UI ya sabe pintar
            if (statusUp === "OK" || statusUp === "SUCCESS" || statusUp === "DELIVERED") statusUp = "COMPLETED";
            if (statusUp === "CANCELED") statusUp = "CANCELLED";

            // Manual-beta: PAID = pago recibido (UI lo colapsa a RECIBIDO)
            // (no convertir a PENDING)

            const estado = (statusUp === "COMPLETED") ? "OK" : (statusUp || "");

            const productIdRaw = (data.productId || data.product || "");
            const productIdNorm = String(productIdRaw || "").trim().toLowerCase();

            const importeRaw = (data.amount ?? data.importe ?? data.price ?? data.precio ?? data.valor);
            let importeNum = undefined;
            if (importeRaw !== undefined && importeRaw !== null && importeRaw !== "") {
              const n = Number(String(importeRaw).replace(",", "."));
              if (!isNaN(n)) importeNum = n;
            }

            const createdAtMs =
              Number(data.createdAtMs || 0) ||
              (toDateFromCreatedAt(data.createdAt)?.getTime() || 0);

            const destino = (data.destination || data.destino || data.numero || "").toString();

            const orderIdResolved = String((data.orderId || data.orderID || data.id || (d && d.id) || "")).trim() || ((d && d.id) ? String(d.id) : "");

            return {
              tipo: "recarga",
              id: orderIdResolved,
              orderId: orderIdResolved,
              numero: destino,
              productId: productIdNorm,
              importe: importeNum,
              createdAtMs: createdAtMs,
              fecha: formatFechaFromCreatedAt(data.createdAt),
              status: statusUp,
              estado: estado
            };
          });

          mapped.sort((a, b) => (sortKeyMovimiento(b) - sortKeyMovimiento(a)));
          return mapped.slice(0, 50);
        }

        function withTimeout(promise, ms) {
          return new Promise((resolve) => {
            let done = false;
            const t = setTimeout(() => {
              if (done) return;
              done = true;
              resolve(null);
            }, ms);

            Promise.resolve(promise)
              .then((v) => {
                if (done) return;
                done = true;
                clearTimeout(t);
                resolve(v);
              })
              .catch(() => {
                if (done) return;
                done = true;
                clearTimeout(t);
                resolve(null);
              });
          });
        }

        // ===== MODALES (NO se re-renderizan “en caliente”) =====
        const modalBg    = document.getElementById("modal-bg");
        const modalLista = document.getElementById("modal-lista");
        const modalTitulo= document.getElementById("modal-titulo");
        const cerrar     = document.getElementById("cerrarModal");
        const modalDlg   = modalBg ? modalBg.querySelector(".modal") : null;
        let lastFocusedElement = null;

        function abrirModalAccesible() {
          if (!modalBg) return;
          lastFocusedElement = document.activeElement;
          modalBg.style.display = "flex";
          const foco = cerrar || modalDlg;
          if (foco && typeof foco.focus === "function") {
            setTimeout(() => foco.focus(), 0);
          }
        }

        function cerrarModalAccesible() {
          if (modalBg) modalBg.style.display = "none";
          if (lastFocusedElement && typeof lastFocusedElement.focus === "function") {
            lastFocusedElement.focus();
          }
        }

        document.addEventListener("keydown", (e) => {
          if (e.key === "Escape" && modalBg && modalBg.style.display === "flex") {
            cerrarModalAccesible();
          }
        });

        function abrirModal(tipo, titulo) {
          if (!modalLista || !modalTitulo || !modalBg) return;

          modalTitulo.textContent = titulo;
          modalLista.innerHTML = "";

          const datos = lista.filter(m => m && m.tipo === tipo);
          datos.sort((a, b) => (sortKeyMovimiento(b) - sortKeyMovimiento(a)));

          if (!datos.length) {
            modalLista.innerHTML = '<div class="modal-item">Sin movimientos registrados</div>';
          } else {
            datos.forEach(m => {
              const importe = Number(m.importe);
              const signo   = tipo === "saldo" ? "+" : "-";
              const impTxt  = isNaN(importe) ? "" : `${signo}${importe.toFixed(2)} €`;

              const orderIdTxt = String((m && (m.orderId || m.id)) || "").trim();

              const destinoTxt = String((m && (m.numero || m.destino || m.destination)) || "").trim();

              const metodoRaw =
                (m && (m.paymentMethod || (m.extra && m.extra.paymentMethod) || m.method))
                  ? (m.paymentMethod || (m.extra && m.extra.paymentMethod) || m.method)
                  : "";
              let metodoTxt = (metodoRaw == null) ? "" : String(metodoRaw).trim();
              if (metodoTxt) {
                const up = metodoTxt.toUpperCase();
                if (up === "PAYPAL") metodoTxt = "PayPal";
                else if (up === "REVOLUT") metodoTxt = "Revolut";
                else if (up === "BIZUM") metodoTxt = "Bizum";
              }

              const ofertaRaw =
                (m && (m.productName || (m.extra && m.extra.productName)))
                  ? (m.productName || (m.extra && m.extra.productName))
                  : "";
              let ofertaTxt = (ofertaRaw == null) ? "" : String(ofertaRaw).trim();
              if (!ofertaTxt) ofertaTxt = String((m && m.productId) || "").trim();

              const linkRaw =
                (m && (m.paymentLink || (m.extra && m.extra.paymentLink) || m.payment_link))
                  ? (m.paymentLink || (m.extra && m.extra.paymentLink) || m.payment_link)
                  : "";
              const paymentLinkTxt = (linkRaw == null) ? "" : String(linkRaw).trim();

              let statusUp = (m && (m.status || m.estado) ? (m.status || m.estado) : "").toString().trim().toUpperCase();
              if (statusUp === "OK" || statusUp === "SUCCESS" || statusUp === "DELIVERED") statusUp = "COMPLETED";
              const isCompleted = (statusUp === "COMPLETED" || statusUp === "COMPLETADO");

              const parts = [];
              const ft = normalizeFechaText(m) || "";
              if (ft) parts.push(ft);
              if (ofertaTxt) parts.push(ofertaTxt);
              if (metodoTxt) parts.push(metodoTxt);
              if (destinoTxt) parts.push(`A ${destinoTxt}`);
              if (impTxt) parts.push(impTxt);

              if (tipo === "recarga") {
                parts.push(isCompleted ? "COMPLETADO" : "RECIBIDO");
              }
              if (orderIdTxt) parts.push(`ID: ${orderIdTxt}`);

              // Manual-beta: payment_link SOLO en el modal (si existe)
              if (paymentLinkTxt) parts.push(`Link: ${paymentLinkTxt}`);

              const fila = document.createElement("div");
              fila.className = "modal-item";

              fila.textContent = parts.join(" | ");
              // Manual-beta: colapsa cualquier token raro a RECIBIDO/COMPLETADO
              try {
                const txt = (fila.textContent || "").toString();
                fila.textContent = txt
                  .replace(/\bCOMPLETED\b/g, "COMPLETADO")
                  .replace(/\bCOMPLETADO\b/g, "COMPLETADO")
                  .replace(/\bPENDING\b/g, "RECIBIDO")
                  .replace(/\bFAILED\b/g, "RECIBIDO")
                  .replace(/\bCANCELLED\b/g, "RECIBIDO")
                  .replace(/\bCANCELED\b/g, "RECIBIDO")
                  .replace(/\bREFUNDED\b/g, "RECIBIDO")
                  .replace(/\bREQUESTED\b/g, "RECIBIDO")
                  .replace(/\bPAID\b/g, "RECIBIDO");
              } catch (_) {}

              modalLista.appendChild(fila);
            });
          }

          abrirModalAccesible();
        }

        function abrirModalCorreos() {
          if (!modalLista || !modalTitulo || !modalBg) return;

          modalTitulo.textContent = "Historial de correos enviados";
          modalLista.innerHTML = "";

          const recargasLocal = lista.filter(m => m && m.tipo === "recarga");
          recargasLocal.sort((a, b) => (sortKeyMovimiento(b) - sortKeyMovimiento(a)));

          if (!recargasLocal.length) {
            modalLista.innerHTML = '<div class="modal-item">No hay correos enviados</div>';
          } else {
            recargasLocal.forEach(m => {
              const idTxt      = String((m && (m.orderId || m.id)) || "").trim() || "Sin ID";
              const emailTxt   = (sessionEmailSnapshot || localStorage.getItem("usuario") || emailUsuarioBase || "Sin correo").toString();
              const importe    = Number(m.importe);
              const importeTxt = isNaN(importe) ? "" : `${importe.toFixed(2)} €`;

              const destinoTxt = String((m && (m.numero || m.destino || m.destination)) || "").trim();

              const metodoRaw =
                (m && (m.paymentMethod || (m.extra && m.extra.paymentMethod) || m.method))
                  ? (m.paymentMethod || (m.extra && m.extra.paymentMethod) || m.method)
                  : "";
              let metodoTxt = (metodoRaw == null) ? "" : String(metodoRaw).trim();
              if (metodoTxt) {
                const mup = metodoTxt.toUpperCase();
                if (mup === "PAYPAL") metodoTxt = "PayPal";
                else if (mup === "REVOLUT") metodoTxt = "Revolut";
                else if (mup === "BIZUM") metodoTxt = "Bizum";
              }

              const linkRaw =
                (m && (m.paymentLink || (m.extra && m.extra.paymentLink) || m.payment_link))
                  ? (m.paymentLink || (m.extra && m.extra.paymentLink) || m.payment_link)
                  : "";
              const paymentLinkTxt = (linkRaw == null) ? "" : String(linkRaw).trim();

              const statusRaw = (m && (m.status || m.estado)) ? String(m.status || m.estado) : "";
              const up = statusRaw.trim().toUpperCase();
              const estadoTxt = (up === "OK" || up === "SUCCESS" || up === "COMPLETED" || up === "COMPLETADO" || up === "DELIVERED") ? "COMPLETADO" : "RECIBIDO";

              const parts = [];
              const ft = normalizeFechaText(m) || "";
              if (ft) parts.push(ft);
              parts.push(emailTxt);
              if (metodoTxt) parts.push(metodoTxt);
              if (importeTxt) parts.push(importeTxt);
              if (destinoTxt) parts.push(destinoTxt);
              parts.push(estadoTxt);
              parts.push(`ID: ${idTxt}`);

              // Manual-beta: link SOLO en modales
              if (paymentLinkTxt) parts.push(`Link: ${paymentLinkTxt}`);

              const fila = document.createElement("div");
              fila.className = "modal-item";
              fila.textContent = parts.join(" | ");
              modalLista.appendChild(fila);
            });
          }

          abrirModalAccesible();
        }

        const cardRecarga = document.getElementById("card-recarga");
        const cardCorreo  = document.getElementById("card-correo");

        if (cardRecarga) {
          cardRecarga.onclick = () => abrirModal("recarga", "Historial de recargas");
          cardRecarga.addEventListener("keydown", (e) => {
            if (e.key === "Enter" || e.key === " ") {
              if (e.key === " ") e.preventDefault();
              abrirModal("recarga", "Historial de recargas");
            }
          });
        }

        /* Manual-beta: sin tarjeta saldo */

        if (cardCorreo) {
          cardCorreo.onclick = () => abrirModalCorreos();
          cardCorreo.addEventListener("keydown", (e) => {
            if (e.key === "Enter" || e.key === " ") {
              if (e.key === " ") e.preventDefault();
              abrirModalCorreos();
            }
          });
        }

        if (cerrar && modalBg) {
          cerrar.onclick = () => cerrarModalAccesible();
          modalBg.onclick = e => e.target === modalBg && cerrarModalAccesible();
        }

        // ==============================
        // FIX: render único visible
        // - intentamos Firestore (rápido) con timeout
        // - luego un solo render + reveal (sin swaps)
        // - y sincronizamos sesión localStorage aquí (sin 2º listener)
        // ==============================
        try {
          const fbUser = await getFirebaseUserOnce(8000);

          if (fbUser && fbUser.email) {
            sessionEmailSnapshot = String(fbUser.email).toLowerCase();

            // Sync localStorage (antes estaba en el script final onAuthStateChanged)
            try {
              const raw = localStorage.getItem("usuarioRegistrado") || "{}";
              const datos = JSON.parse(raw);

              const nuevo = {
                ...(datos || {}),
                nombre: (datos && datos.nombre) || fbUser.displayName || "",
                email: sessionEmailSnapshot,
                activo: true
              };

              localStorage.setItem("usuarioRegistrado", JSON.stringify(nuevo));
              localStorage.setItem("usuario", sessionEmailSnapshot);
            } catch (e) {
              console.error("Error sincronizando sesión en historial:", e);
            }
          }

          if (fbUser && fbUser.uid) {
            const h = (location && location.hostname) ? location.hostname : "";
            const timeoutMs = (h === "127.0.0.1" || h === "localhost") ? 12000 : 6000;

            // 1) Leer recargas (fuente principal cuando existe: COMPLETED/REFUNDED)
            const fsRecargasMaybe = await withTimeout(fetchRecargasFromFirestore(fbUser.uid), timeoutMs);

            // 2) Leer orders (para PENDING/FAILED/CANCELLED que no crean /recargas)
            const fsOrdersMaybe = await withTimeout(fetchOrdersFromFirestore(fbUser.uid), timeoutMs);

            /* debug logs removed */

            // Index de estados por orderId (recargas > orders)
            const __statusByOrderId = Object.create(null);

            function __pickOrderId(x) {
              try {
                if (!x) return "";
                const oid = (x.orderId || (x.extra && x.extra.orderId) || x.id || x.orderID || "");
                return String(oid || "").trim();
              } catch (_) {
                return "";
              }
            }

            try {
              if (Array.isArray(fsOrdersMaybe)) {
                fsOrdersMaybe.forEach((o) => {
                  const k = __pickOrderId(o);
                  const s = (o && o.status) ? String(o.status).trim().toUpperCase() : "";
                  if (k && s) __statusByOrderId[k] = s;
                });
              }
              if (Array.isArray(fsRecargasMaybe)) {
                fsRecargasMaybe.forEach((r) => {
                  const k = __pickOrderId(r);
                  const s = (r && r.status) ? String(r.status).trim().toUpperCase() : "";
                  if (k && s) __statusByOrderId[k] = s; // override: recargas manda
                });
              }
            } catch (_) {}

            // Si ya existe un movimiento local con orderId, NO metas también el doc Firestore a lista.
            const __existingOrderIds = new Set();
            try {
              if (Array.isArray(lista)) {
                lista.forEach((m) => {
                  const oid = __pickOrderId(m);
                  if (oid) __existingOrderIds.add(oid);
                });
              }
            } catch (_) {}

            const fsRecargasForMerge = (Array.isArray(fsRecargasMaybe) ? fsRecargasMaybe : []).filter((r) => {
              const id = (r && r.id) ? String(r.id) : "";
              return id ? !__existingOrderIds.has(id) : true;
            });

            const fsOrdersForMerge = (Array.isArray(fsOrdersMaybe) ? fsOrdersMaybe : []).filter((o) => {
              const id = (o && o.id) ? String(o.id) : "";
              return id ? !__existingOrderIds.has(id) : true;
            });

            // Merge sin duplicados por id:
            // - Añade recargas/órdenes SOLO si no están ya representadas por un movimiento local con orderId.
            if (fsRecargasForMerge.length) {
              lista = mergeByIdPreferFirst(fsRecargasForMerge, lista);
            }
            if (fsOrdersForMerge.length) {
              lista = mergeByIdPreferFirst(lista, fsOrdersForMerge);
            }

            // Propaga estado real a movimientos locales que tengan orderId
            try {
              if (Array.isArray(lista)) {
                lista.forEach((m) => {
                  const oid = (m && (m.orderId || (m.extra && m.extra.orderId)))
                    ? String(m.orderId || (m.extra && m.extra.orderId))
                    : "";
                  if (!oid) return;

                  const st = __statusByOrderId[oid];
                  if (!st) return;

                  m.status = st;
                  m.estado = (st === "COMPLETED") ? "OK" : st;

                  if (m.extra && typeof m.extra === "object") {
                    m.extra.estado = st;
                    m.extra.status = st;
                  }
                });
              }
            } catch (_) {}
          }
        } catch (e) {
          console.error("Error preparando dataset Firestore:", e);
        }

        // Un solo render (ya con dataset final elegido) y reveal
        renderCardsFromLista(true);
        revealHistorialOnce();
      })();
    });
  </script>

  <!-- Session sync moved into main init to avoid duplicate onAuthStateChanged listeners -->

  <script type="module" src="js/app.js?v=r1"></script>
</body>
</html>
