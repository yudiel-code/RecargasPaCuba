<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Historial | RecargasPaCuba</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <meta name="color-scheme" content="light">
  <meta name="theme-color" content="#28c6db">
  <link rel="stylesheet" href="styles/base.css?v=r1">
  <link rel="stylesheet" href="styles/app.css?v=r1">
  <script src="js/ui.js?v=r1"></script>
  <script type="module">
  import { guardProtectedPage } from "./js/guard.js?v=r1";
  import { auth, onAuthStateChanged } from "./js/firebase.js?v=r1";
  window.guardProtectedPage = guardProtectedPage;
  window.auth = auth;
  window.onAuthStateChanged = onAuthStateChanged;
</script>
  <style>
    /* Tipografía como Cuenta/Recargar */
    @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700;800&display=swap');

    /* Anti-flash align with recargar */
    html { visibility: hidden; }
    html.loaded { visibility: visible; }

    /* Anti-flash (Historial): no muestres las cards hasta data-ready */
    html:not(.rpc-ready) .historial-container { opacity: 0 !important; pointer-events: none; }
    html.rpc-ready .historial-container { opacity: 1 !important; }

    :root{
      --left:#0b63d1;
      --right:#19c6c3;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      margin: 0;
      font-family: 'Poppins', system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      color: white;
      padding-bottom: 90px;
    }

    .historial-container {
      flex: 1;
      padding: 20px 16px 10px;
      max-width: 520px;
      margin: 0 auto;
    }

    .icono {
      min-width: 46px;
      min-height: 46px;
      border-radius: 16px;
      background: rgba(15, 23, 42, 0.75);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 22px;
      box-shadow: 0 12px 26px rgba(0,0,0,0.45);
      position: relative;
      z-index: 1;
    }

    .contenido {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 2px;
      position: relative;
      z-index: 1;
    }

    .titulo {
      font-size: 16px;
      font-weight: 700;
    }

    .descripcion {
      font-size: 13px;
      opacity: 0.92;
      margin-top: 2px;
    }

    .fecha {
      font-size: 12px;
      opacity: 0.78;
      margin-top: 4px;
    }

    .estado {
      font-size: 12px;
      font-weight: 700;
      padding: 7px 12px;
      border-radius: 999px;
      white-space: nowrap;
      border: 1px solid rgba(15,23,42,0.28);
      box-shadow: 0 10px 22px rgba(0,0,0,0.40);
      position: relative;
      z-index: 1;
    }

    .verde    { background: #3ddc97; color: #022c22; }
    .azul     { background: #4bbcff; color: #082f49; }
    .rojo     { background: #ff6b6b; color: #450a0a; }
    .amarillo { background: #ffd966; color:#422006; }

    /* MODAL */
    .modal-bg {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.55);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 3000;
      backdrop-filter: blur(6px);
      padding: 20px 14px;
    }

    .modal {
      background: radial-gradient(circle at top left, rgba(56, 189, 248, 0.16), transparent 55%),
                  rgba(15, 23, 42, 0.96);
      padding: 20px 18px 18px;
      border-radius: 20px;
      max-width: 420px;
      width: 100%;
      border: 1px solid rgba(148, 163, 184, 0.7);
      box-shadow: 0 18px 35px rgba(0,0,0,0.55);
      color: #fff;
    }

    .modal h3 {
      margin: 0 0 12px;
      text-align: center;
      font-size: 16px;
      font-weight: 700;
    }

    .modal-item {
      font-size: 13px;
      padding: 8px 0;
      border-bottom: 1px solid rgba(148,163,184,0.45);
    }

    .modal-item:last-child {
      border-bottom: none;
    }

    .cerrar {
      margin-top: 14px;
      width: 100%;
      padding: 10px;
      border-radius: 12px;
      border: none;
      font-weight: 700;
      background: #ffb13b;
      color: #2c1200;
      cursor: pointer;
      box-shadow: 0 10px 24px rgba(0,0,0,0.40);
      font-size: 14px;
    }

    .card-titulo-monedas {
      font-size: 15px;
      font-weight: 700;
      margin-bottom: 6px;
    }

    .card-descripcion-monedas {
      font-size: 11px;
      opacity: 0.9;
      margin-bottom: 10px;
    }

    .monedas-resumen {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 14px;
      margin-bottom: 10px;
    }

    .monedas-valores {
      font-size: 13px;
    }

    .monedas-valores .principal {
      font-size: 20px;
      font-weight: 800;
    }

    .monedas-valores .secundario {
      font-size: 11px;
      opacity: 0.85;
      margin-top: 2px;
    }

    .monedas-badge {
      padding: 4px 8px;
      border-radius: 999px;
      font-size: 10px;
      background: rgba(30, 64, 175, 0.85);
      border: 1px solid rgba(191, 219, 254, 0.7);
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .barra-progreso-wrap {
      margin-bottom: 10px;
    }

    .barra-progreso-label {
      font-size: 11px;
      opacity: 0.9;
      display: flex;
      justify-content: space-between;
      margin-bottom: 4px;
    }

    .barra-progreso {
      width: 100%;
      height: 9px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.7);
      overflow: hidden;
      border: 1px solid rgba(148, 163, 184, 0.7);
    }

    .barra-progreso-inner {
      height: 100%;
      border-radius: 999px;
      background: linear-gradient(90deg, #22c55e, #a3e635);
      width: 0%;
      transition: width 0.4s ease-out;
    }

    .tabla-monedas {
      width: 100%;
      border-collapse: collapse;
      font-size: 11px;
      margin-top: 4px;
    }

    .tabla-monedas th,
    .tabla-monedas td {
      padding: 4px 3px;
      text-align: left;
    }

    .tabla-monedas th {
      font-weight: 600;
      opacity: 0.9;
      border-bottom: 1px solid rgba(148, 163, 184, 0.5);
    }

    .tabla-monedas td {
      opacity: 0.95;
      border-bottom: 1px dashed rgba(51, 65, 85, 0.7);
    }

    .tabla-monedas tr:last-child td {
      border-bottom: none;
    }

    .tabla-monedas td span.destacado {
      color: #facc15;
      font-weight: 600;
    }

    .canje-wrap {
      margin-top: 10px;
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .canje-info {
      font-size: 11px;
      opacity: 0.9;
      flex: 1;
      min-width: 160px;
    }

    .canje-info strong {
      color: #bef264;
    }

    .btn-canje {
      padding: 9px 16px;
      border-radius: 999px;
      border: none;
      font-size: 13px;
      font-weight: 700;
      cursor: pointer;
      background: rgba(15, 23, 42, 0.7);
      color: rgba(148, 163, 184, 0.9);
      border: 1px dashed rgba(148, 163, 184, 0.7);
    }

    .btn-canje.activo {
      background: linear-gradient(135deg, #22c55e, #a3e635);
      color: #052e16;
      border-style: solid;
    }

    .card-lista {
      list-style: none;
      padding: 0;
      margin: 10px 0 0;
      font-size: 11px;
      opacity: 0.95;
    }

    .card-lista li {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 4px;
    }

    .bullet {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: rgba(248, 250, 252, 0.85);
    }

    .monedas-icon {
      width: 50px;
      height: 50px;
      fill: #fff;
    }

    /* FIX layout: el card base es flex (fila). Este debe ser columna. */
    .card.card-monedas{
      display:flex !important;
      flex-direction:column !important;
      align-items:stretch !important;
      justify-content:flex-start !important;
      gap:12px;
    }

    .card.card-monedas > *{
      width:100% !important;
      min-width:0 !important;
    }

    .card-monedas .card-header{
      display:flex !important;
      align-items:flex-start !important;
      justify-content:space-between !important;
      gap:12px !important;
    }

    .card-monedas .card-title{
      font-size:15px;
      font-weight:700;
      margin-bottom:6px;
    }

    .card-monedas .card-sub{
      font-size:11px;
      opacity:0.9;
    }

    .card-monedas .card-main{
      display:flex !important;
      align-items:flex-start !important;
      justify-content:flex-start !important;
      gap:14px !important;
    }
  </style>
</head>

<body>

  <div class="historial-container" style="opacity:0; pointer-events:none;">

    <div class="card card--gradient" id="card-recarga" role="button" tabindex="0" aria-label="Ver historial de recargas">
      <div class="icono">⚡</div>
      <div class="contenido">
        <div class="titulo">Recarga realizada</div>
        <div class="descripcion" id="recarga-desc">Aún no tienes movimientos</div>
        <div class="fecha" id="recarga-fecha"></div>
      </div>
      <div class="estado verde" id="recarga-estado">Sin movimientos</div>
    </div>

    <div class="card card--gradient" id="card-saldo" role="button" tabindex="0" aria-label="Ver historial de saldos" style="display:none">
      <div class="icono">💰</div>
      <div class="contenido">
        <div class="titulo">Saldo agregado</div>
        <div class="descripcion" id="saldo-desc">Aún no tienes movimientos</div>
        <div class="fecha" id="saldo-fecha"></div>
      </div>
      <div class="estado verde" id="saldo-estado">Sin movimientos</div>
    </div>

    <div class="card card--gradient" id="card-correo" role="button" tabindex="0" aria-label="Ver historial de correos">
      <div class="icono">📧</div>
      <div class="contenido">
        <div class="titulo">Correo recibido</div>
        <div class="descripcion" id="correo-desc">Aún no tienes movimientos</div>
        <div class="fecha" id="correo-fecha"></div>
      </div>
      <div class="estado azul" id="correo-estado">Sin movimientos</div>
    </div>

    <section class="card card--gradient card-monedas">
      <div class="card-header">
        <div>
          <div class="card-title">Programa de monedas</div>
          <div class="card-sub">Gana recompensas con tus recargas recurrentes</div>
        </div>
        <svg class="monedas-icon" viewBox="0 0 64 64">
          <circle cx="22" cy="22" r="12" stroke="currentColor" stroke-width="2" fill="none"/>
          <circle cx="42" cy="32" r="12" stroke="currentColor" stroke-width="2" fill="none"/>
          <circle cx="26" cy="42" r="12" stroke="currentColor" stroke-width="2" fill="none"/>
        </svg>
      </div>

      <div class="card-main" style="align-items:flex-start;">
        <div class="monedas-resumen">
          <div class="monedas-valores">
            <div class="principal"><span id="monedasActuales">0</span> monedas</div>
            <div class="secundario">Recarga y acumula hasta llegar a tu recompensa</div>
          </div>
        </div>
      </div>

      <div class="barra-progreso-wrap">
        <div class="barra-progreso-label">
          <span>Progreso hacia el canje</span>
          <span id="monedasProgresoTexto">0 / 999</span>
        </div>
        <div class="barra-progreso">
          <div id="barraProgresoInner" class="barra-progreso-inner"></div>
        </div>
      </div>

      <table class="tabla-monedas">
        <thead>
          <tr>
            <th>Recarga</th>
            <th>Importe</th>
            <th>Monedas</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Cubacel</td>
            <td>10 €</td>
            <td>13</td>
          </tr>
          <tr>
            <td>Cubacel</td>
            <td>20 €</td>
            <td>27</td>
          </tr>
          <tr>
            <td>Cubacel</td>
            <td>30 €</td>
            <td>41</td>
          </tr>
          <tr>
            <td>Cubacel</td>
            <td>50 €</td>
            <td><span class="destacado">69</span></td>
          </tr>
          <tr>
            <td>Nauta</td>
            <td>Cualquier importe</td>
            <td>5 (fijo)</td>
          </tr>
        </tbody>
      </table>

      <ul class="card-lista">
        <li>
          <span class="bullet"></span>
          <span>Las monedas se suman automáticamente cada vez que completas una recarga.</span>
        </li>
        <li>
          <span class="bullet"></span>
          <span>Al llegar a <strong>999 monedas</strong>, podrás solicitar tu <strong>recarga de % 10 y 20 €</strong>.</span>
        </li>
        <li>
          <span class="bullet"></span>
          <span>Las monedas no son dinero real, son puntos promocionales internos.</span>
        </li>
      </ul>

      <div class="canje-wrap">
        <div class="canje-info">
          <strong>Canje disponible a partir de 999 monedas.</strong><br>
          Una vez llegado a 999,se activara el boton de contactar con soporte para reclamar su premio.
        </div>
        <button id="btnCanje" class="btn-canje">
          Canjear 999 monedas por 20 €
        </button>
      </div>
    </section>
 
  </div>
 
  <!-- MODAL -->
  <div class="modal-bg" id="modal-bg">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="modal-titulo" tabindex="-1">
      <h3 id="modal-titulo"></h3>
      <div id="modal-lista"></div>
      <button class="cerrar" id="cerrarModal" type="button" aria-label="Cerrar">Cerrar</button>
    </div>
  </div>
 
  <!-- Barra inferior unificada -->
  <nav class="app-nav">
    <div class="nav-inner">
      <a href="recargar.html" class="nav-btn">
        <span>⚡</span>
        <div>Recargar</div>
      </a>
      <a href="historial.html" class="nav-btn active">
        <span>🕑</span>
        <div>Historial</div>
      </a>
      <a href="cuenta.html" class="nav-btn">
        <span>👤</span>
        <div>Cuenta</div>
      </a>
    </div>
  </nav>

  <!-- Catálogo de productos (para resolver productId -> importe) -->
  <script src="js/products.js?v=r1"></script>

  <!-- Capa de datos unificada -->
  <script src="js/userData.js?v=r1"></script>

  <script>
    window.addEventListener("DOMContentLoaded", () => {
      try { document.documentElement.classList.add("loaded"); } catch (_) {}

      if (typeof guardProtectedPage === "function") {
        guardProtectedPage({
          redirectTo: "index.html",
          timeoutMs: 20000,
          auth,
          onAuthStateChanged,
          onReady: (user) => {
            try {
              window.__rpcAuthReady = true;
              window.__rpcAuthUser = user || null;
              window.dispatchEvent(new Event("rpc-auth-ready"));
            } catch (_) {}
          },
        });
      }
    });

    window.addEventListener("load", () => {
      try { document.documentElement.classList.add("loaded"); } catch (_) {}

      const emailUsuarioBase = (localStorage.getItem("usuario") || "").toString();
      let sessionEmailSnapshot = (localStorage.getItem("usuario") || emailUsuarioBase || "").toString();

      function getHistorial() {
        if (window.UserData && typeof window.UserData.getHistorial === "function") {
          return window.UserData.getHistorial();
        }
        try {
          const raw = localStorage.getItem("rpc_historial") || "[]";
          const lista = JSON.parse(raw);
          return Array.isArray(lista) ? lista : [];
        } catch (e) {
          console.error("Error leyendo historial, devolviendo lista vacía:", e);
          return [];
        }
      }

      (async () => {
        let lista = getHistorial();

        // Espera a auth-ready para evitar renders pre-auth (failsafe timeout).
        try {
          if (!window.__rpcAuthReady) {
            await new Promise((resolve) => {
              const t = setTimeout(resolve, 20000);
              window.addEventListener("rpc-auth-ready", () => { clearTimeout(t); resolve(); }, { once: true });
            });
          }
          if (window.__rpcAuthUser && window.__rpcAuthUser.email) {
            sessionEmailSnapshot = String(window.__rpcAuthUser.email).toLowerCase();
          }
        } catch (_) {}

        let __historialRevealed = false;
        function revealHistorialOnce() {
          if (__historialRevealed) return;
          __historialRevealed = true;
          document.documentElement.classList.add("rpc-ready");
          try {
            const hc = document.querySelector(".historial-container");
            if (hc) { hc.style.opacity = "1"; hc.style.pointerEvents = "auto"; }
          } catch (_) {}
        }

        // Failsafe: si algo rompe antes del reveal, no dejes la pantalla en azul para siempre.
        setTimeout(() => {
          try { revealHistorialOnce(); } catch (_) {}
        }, 3000);

        // ===== Orden/fecha estables (local + Firestore) =====
        function msFromPendId(id) {
          try {
            const s = (id || "").toString().trim();
            const m = s.match(/^PEND-(\d{10,})$/i);
            if (!m) return 0;
            const n = Number(m[1]);
            return Number.isFinite(n) ? n : 0;
          } catch (_) {
            return 0;
          }
        }

        function parseEsFechaToMs(str) {
          try {
            const s = (str || "").toString().trim();
            const m = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})(?:,)?\s*(\d{1,2}):(\d{2})(?::(\d{2}))?/);
            if (!m) return 0;
            const dd = Number(m[1]);
            const mm = Number(m[2]);
            const yy = Number(m[3]);
            const hh = Number(m[4]);
            const mi = Number(m[5]);
            const ss = Number(m[6] || 0);
            const d = new Date(yy, (mm - 1), dd, hh, mi, ss);
            const t = d.getTime();
            return isNaN(t) ? 0 : t;
          } catch (_) {
            return 0;
          }
        }

        function parseAnyFechaToMs(str) {
          try {
            const s = (str || "").toString().trim();
            if (!s) return 0;
            const es = parseEsFechaToMs(s);
            if (es) return es;
            const iso = Date.parse(s);
            return isNaN(iso) ? 0 : iso;
          } catch (_) {
            return 0;
          }
        }

        function sortKeyMovimiento(m) {
          if (!m) return 0;

          const ca = Number(m.createdAtMs || 0);
          if (ca > 0) return ca;

          const pend = msFromPendId(m.id);
          if (pend > 0) return pend;

          const f = (m.fecha || "").toString().trim();
          const ms = parseAnyFechaToMs(f);
          return ms || 0;
        }

        function normalizeFechaText(m) {
          if (!m) return "";
          const raw = (m.fecha || "").toString().trim();
          if (/^\d{1,2}\/\d{1,2}\/\d{4}/.test(raw)) return raw;
          const ms = sortKeyMovimiento(m);
          if (ms > 0) {
            try { return new Date(ms).toLocaleString("es-ES"); } catch (_) { return ""; }
          }
          return raw || "";
        }

        // ===== Helpers DOM =====
        function safeSetText(el, txt) {
          try {
            if (!el) return;
            const t = (txt == null) ? "" : String(txt);
            if (el.textContent !== t) el.textContent = t;
          } catch (_) {}
        }

        function safeSetClass(el, cls) {
          try {
            if (!el) return;
            const c = (cls == null) ? "" : String(cls);
            if (el.className !== c) el.className = c;
          } catch (_) {}
        }

        // ===== Selección estable por ID =====
        let selectedRecargaId = null;
        let __lastRecargaFingerprint = null;

        function fingerprintRecarga(u) {
          if (!u) return "";
          const id = (u.id || "").toString();
          const num = (u.numero || "").toString();
          const st = (u.status || "").toString();
          const est = (u.estado || "").toString();
          const imp = Number(u.importe);
          const impTxt = isNaN(imp) ? "" : imp.toFixed(2);
          const f = normalizeFechaText(u) || "";
          return `${id}|${num}|${st}|${est}|${impTxt}|${f}`;
        }

        function pickTopRecargaFromList(arr) {
          const recargas = (Array.isArray(arr) ? arr : []).filter(m => m && m.tipo === "recarga");
          if (!recargas.length) return null;
          recargas.sort((a, b) => (sortKeyMovimiento(b) - sortKeyMovimiento(a)));
          return recargas[0] || null;
        }

        function getSelectedRecarga(recargasSorted, allowChange) {
          if (!Array.isArray(recargasSorted) || !recargasSorted.length) return null;

          const top = recargasSorted[0] || null;
          if (!top) return null;

          const topId = (top.id || "").toString();
          if (!selectedRecargaId) {
            selectedRecargaId = topId;
            return top;
          }

          const found = recargasSorted.find(r => r && (r.id || "").toString() === selectedRecargaId) || null;
          if (found && !allowChange) return found;

          if (allowChange && topId && topId !== selectedRecargaId) {
            selectedRecargaId = topId;
            return top;
          }

          return found || top;
        }

        function updateRecargaAndCorreoAtomic(u) {
          const fp = fingerprintRecarga(u);
          if (fp && fp === __lastRecargaFingerprint) return;
          __lastRecargaFingerprint = fp;

          const descR   = document.getElementById("recarga-desc");
          const fechaR  = document.getElementById("recarga-fecha");
          const estadoR = document.getElementById("recarga-estado");

          const correoDesc   = document.getElementById("correo-desc");
          const correoFecha  = document.getElementById("correo-fecha");
          const correoEstado = document.getElementById("correo-estado");

          const importeR = Number(u && u.importe);
          const importeTxtR = isNaN(importeR) ? "" : `-${importeR.toFixed(2)} €`;

          const fechaTxt = normalizeFechaText(u);

          // Status canónico (prefer u.status; fallback a u.estado)
          let statusUp = (u && u.status ? u.status : "").toString().trim().toUpperCase();
          if (!statusUp) {
            const legacyUp = (u && u.estado ? u.estado : "").toString().trim().toUpperCase();
            if (legacyUp === "OK" || legacyUp === "SUCCESS" || legacyUp === "PAID" || legacyUp === "DELIVERED") statusUp = "COMPLETED";
            else if (legacyUp === "CANCELED") statusUp = "CANCELLED";
            else if (legacyUp) statusUp = legacyUp;
            else statusUp = "PENDING";
          } else {
            if (statusUp === "OK" || statusUp === "SUCCESS" || statusUp === "PAID" || statusUp === "DELIVERED") statusUp = "COMPLETED";
            else if (statusUp === "CANCELED") statusUp = "CANCELLED";
          }

                    function statusToUi(s) {
            switch ((s || "").toString().toUpperCase()) {
              case "COMPLETED": return { text: "Completada",  cls: "estado verde" };
              case "PENDING":   return { text: "En proceso",  cls: "estado amarillo" };
              case "FAILED":    return { text: "Fallida",     cls: "estado rojo" };
              case "CANCELLED":
              case "CANCELED":  return { text: "Cancelada",   cls: "estado azul" };
              case "REFUNDED":  return { text: "Reembolsada", cls: "estado azul" };
              default:          return { text: "En proceso",  cls: "estado amarillo" };
            }
          }


          const ui = statusToUi(statusUp);

          // Recarga realizada (mantén importe visible, status en la píldora)
          const recargaTituloEl = document.querySelector("#card-recarga .titulo");
          if (recargaTituloEl) {
            const t =
              (statusUp === "FAILED") ? "Recarga fallida" :
              (statusUp === "CANCELLED" || statusUp === "CANCELED") ? "Recarga cancelada" :
              (statusUp === "REFUNDED") ? "Recarga reembolsada" :
              (statusUp === "COMPLETED") ? "Recarga completada" :
              "Recarga en proceso";
            safeSetText(recargaTituloEl, t);
          }

          const numeroTxt = (u && u.numero) ? u.numero : "";
          const descTxt = `Recarga a ${numeroTxt}${importeTxtR ? ` | ${importeTxtR}` : ""}`;
          safeSetText(descR, descTxt);
          safeSetText(fechaR, fechaTxt);
          safeSetText(estadoR, ui.text);
          safeSetClass(estadoR, ui.cls);

          // Correo recibido (snapshot de email: NO cambies entre renders)
          const idTxt      = (u && u.id) ? u.id : "Sin ID";
          const emailTxt   = (sessionEmailSnapshot || localStorage.getItem("usuario") || emailUsuarioBase || "Sin correo registrado").toString();
          const importeTxt = isNaN(importeR) ? "" : `${importeR.toFixed(2)} €`;
          const numeroTxtC = (u && u.numero) ? u.numero : "";
          const correoDescTxt = `${emailTxt} | ${importeTxt}${numeroTxtC ? ` | ${numeroTxtC}` : ""} | ID: ${idTxt}`;

          safeSetText(correoDesc, correoDescTxt);
          safeSetText(correoFecha, fechaTxt);
          // Ajusta título del card de correo según estado
const correoTituloEl = document.querySelector("#card-correo .titulo");
if (correoTituloEl) {
  const t =
    (statusUp === "FAILED") ? "Recarga fallida" :
    (statusUp === "CANCELLED" || statusUp === "CANCELED") ? "Recarga cancelada" :
    (statusUp === "REFUNDED") ? "Recarga reembolsada" :
    (statusUp === "COMPLETED") ? "Recarga completada" :
    "Correo recibido";
  safeSetText(correoTituloEl, t);
}


          safeSetText(correoEstado, ui.text);
          safeSetClass(correoEstado, ui.cls);
        }

        function renderCardsFromLista(allowSelectionChange) {
          const recargas = lista.filter(m => m && m.tipo === "recarga");
          const saldos   = lista.filter(m => m && m.tipo === "saldo");

          recargas.sort((a, b) => (sortKeyMovimiento(b) - sortKeyMovimiento(a)));
          saldos.sort((a, b) => (sortKeyMovimiento(b) - sortKeyMovimiento(a)));

          const selectedRecarga = getSelectedRecarga(recargas, !!allowSelectionChange);
          if (selectedRecarga) {
            updateRecargaAndCorreoAtomic(selectedRecarga);
          }

          if (saldos.length) {
            const u = saldos[0];
            const descS   = document.getElementById("saldo-desc");
            const fechaS  = document.getElementById("saldo-fecha");
            const estadoS = document.getElementById("saldo-estado");

            const importeS = Number(u.importe);
            const importeTxtS = isNaN(importeS) ? "-" : `+${importeS.toFixed(2)} €`;

            safeSetText(descS, "Ingreso recibido");
            safeSetText(fechaS, normalizeFechaText(u));
            safeSetText(estadoS, `Importe: ${importeTxtS}`);
            safeSetClass(estadoS, "estado verde");
          }
        }

        async function getFirebaseUserOnce(timeoutMs) {
          return new Promise((resolve) => {
            try {
              if (auth && auth.currentUser) return resolve(auth.currentUser);

              let done = false;
              const t = setTimeout(() => {
                if (done) return;
                done = true;
                resolve(auth && auth.currentUser ? auth.currentUser : null);
              }, typeof timeoutMs === "number" ? timeoutMs : 8000);

              const unsub = onAuthStateChanged(auth, (user) => {
                if (done) return;
                done = true;
                clearTimeout(t);
                try { if (typeof unsub === "function") unsub(); } catch (_) {}
                resolve(user || null);
              });
            } catch (e) {
              resolve(null);
            }
          });
        }

        async function getFirebaseSdkVersionFromFirebaseJs() {
          try {
            const res = await fetch("./js/firebase.js?v=r1", { cache: "no-store" });
            if (!res.ok) return null;
            const text = await res.text();
            const m = text.match(/firebasejs\/(\d+\.\d+\.\d+)\//);
            return m ? m[1] : null;
          } catch (e) {
            return null;
          }
        }

        function toDateFromCreatedAt(value) {
          try {
            if (!value) return null;
            if (value instanceof Date) return value;
            if (typeof value === "string" || typeof value === "number") {
              const d = new Date(value);
              return isNaN(d.getTime()) ? null : d;
            }
            if (typeof value.toDate === "function") {
              const d = value.toDate();
              return d instanceof Date && !isNaN(d.getTime()) ? d : null;
            }
            if (typeof value.seconds === "number") {
              const d = new Date(value.seconds * 1000);
              return isNaN(d.getTime()) ? null : d;
            }
            return null;
          } catch (e) {
            return null;
          }
        }

        function formatFechaFromCreatedAt(value) {
          const d = toDateFromCreatedAt(value);
          if (!d) return "";
          try { return d.toLocaleString("es-ES"); } catch (e) { return ""; }
        }

        function mergeByIdPreferFirst(primary, secondary) {
          const out = [];
          const seen = new Set();

          (Array.isArray(primary) ? primary : []).forEach((m) => {
            const id = (m && m.id) ? String(m.id) : "";
            if (id && seen.has(id)) return;
            if (id) seen.add(id);
            out.push(m);
          });

          (Array.isArray(secondary) ? secondary : []).forEach((m) => {
            const id = (m && m.id) ? String(m.id) : "";
            if (id && seen.has(id)) return;
            if (id) seen.add(id);
            out.push(m);
          });

          return out;
        }

        async function fetchRecargasFromFirestore(uid) {
          const version = (await getFirebaseSdkVersionFromFirebaseJs()) || null;
          if (!version) return [];

          const mod = await import(`https://www.gstatic.com/firebasejs/${version}/firebase-firestore.js`);
          const { getFirestore, connectFirestoreEmulator, collection, query, where, orderBy, limit, getDocs } = mod;

          const db = getFirestore();
          try {
            const h = (location && location.hostname) ? location.hostname : "";
            if (h === "127.0.0.1" || h === "localhost") {
              connectFirestoreEmulator(db, "127.0.0.1", 8080);
            }
          } catch (_) {}

          const col = collection(db, "recargas");

          let docs = [];
          try {
            const q = query(col, where("uid", "==", uid), orderBy("createdAt", "desc"), limit(50));
            const snap = await getDocs(q);
            docs = snap && snap.docs ? snap.docs : [];
          } catch (err1) {
            try {
              const q2 = query(col, where("uid", "==", uid), limit(200));
              const snap2 = await getDocs(q2);
              docs = snap2 && snap2.docs ? snap2.docs : [];
            } catch (err2) {
              console.error("Error leyendo Firestore (recargas):", err2);
              return [];
            }
          }

          const mapped = docs.map((d) => {
            const data = (d && typeof d.data === "function") ? (d.data() || {}) : {};
            const statusRaw = (data.status || data.estado || "").toString();
            const statusUp = statusRaw ? statusRaw.toUpperCase() : "";

            // Status canónico para UI (PENDING/COMPLETED/FAILED/CANCELLED/REFUNDED)
            let canonicalStatus = statusUp;
            if (canonicalStatus === "OK" || canonicalStatus === "SUCCESS" || canonicalStatus === "PAID" || canonicalStatus === "DELIVERED") {
              canonicalStatus = "COMPLETED";
            } else if (canonicalStatus === "CANCELED") {
              canonicalStatus = "CANCELLED";
            }

            // Legacy (lo que ya usa tu UI actual)
            const estado = (canonicalStatus === "COMPLETED") ? "OK" : (canonicalStatus || "");

            const productIdRaw = (data.productId || data.product || "");
            const productIdNorm = String(productIdRaw || "").trim().toLowerCase();

            let importeRaw = (data.importe ?? data.amount ?? data.price ?? data.precio ?? data.valor);

            if ((importeRaw === undefined || importeRaw === null || importeRaw === "") && productIdNorm) {
              let found = null;
              if (window.Products && typeof window.Products.getById === "function") {
                try { found = window.Products.getById(productIdNorm); } catch (_) { found = null; }
              }
              if (found) {
                importeRaw = (found.importe ?? found.amount ?? found.price ?? found.precio ?? found.valor);
              }
            }

            let importeNum = undefined;
            if (importeRaw !== undefined && importeRaw !== null && importeRaw !== "") {
              const n = Number(String(importeRaw).replace(",", "."));
              if (!isNaN(n)) importeNum = n;
            }

            const createdAtMs = (toDateFromCreatedAt(data.createdAt)?.getTime() || msFromPendId(d && d.id));

            return {
              tipo: "recarga",
              id: (d && d.id) ? d.id : (data.id || ""),
              numero: data.destino || data.numero || "",
              productId: productIdNorm,
              importe: importeNum,
              createdAtMs: createdAtMs,
              fecha: formatFechaFromCreatedAt(data.createdAt),
              status: canonicalStatus,
              estado: estado
            };
          });

          mapped.sort((a, b) => (sortKeyMovimiento(b) - sortKeyMovimiento(a)));
          return mapped.slice(0, 50);
        }

        async function fetchOrdersFromFirestore(uid) {
          const version = (await getFirebaseSdkVersionFromFirebaseJs()) || null;
          if (!version) return [];

          const mod = await import(`https://www.gstatic.com/firebasejs/${version}/firebase-firestore.js`);
          const { getFirestore, connectFirestoreEmulator, collection, query, where, orderBy, limit, getDocs } = mod;

          const db = getFirestore();
          try {
            const h = (location && location.hostname) ? location.hostname : "";
            if (h === "127.0.0.1" || h === "localhost") {
              connectFirestoreEmulator(db, "127.0.0.1", 8080);
            }
          } catch (_) {}

          const col = collection(db, "orders");

          let docs = [];
          try {
            const q = query(col, where("uid", "==", uid), orderBy("createdAt", "desc"), limit(50));
            const snap = await getDocs(q);
            docs = snap && snap.docs ? snap.docs : [];
          } catch (err1) {
            try {
              const q2 = query(col, where("uid", "==", uid), limit(200));
              const snap2 = await getDocs(q2);
              docs = snap2 && snap2.docs ? snap2.docs : [];
            } catch (err2) {
              console.error("Error leyendo Firestore (orders):", err2);
              return [];
            }
          }

          const mapped = docs.map((d) => {
            const data = (d && typeof d.data === "function") ? (d.data() || {}) : {};

            const statusRaw = (data.status || data.estado || "").toString();
            let statusUp = statusRaw ? statusRaw.toUpperCase() : "";

            // Normaliza a los estados que tu UI ya sabe pintar
            if (statusUp === "OK" || statusUp === "SUCCESS" || statusUp === "DELIVERED") statusUp = "COMPLETED";
            if (statusUp === "CANCELED") statusUp = "CANCELLED";

            // Caso especial: PAID en orders = pagada pero aún “en pipeline” (mejor como En proceso)
            if (statusUp === "PAID") statusUp = "PENDING";

            const estado = (statusUp === "COMPLETED") ? "OK" : (statusUp || "");

            const productIdRaw = (data.productId || data.product || "");
            const productIdNorm = String(productIdRaw || "").trim().toLowerCase();

            const importeRaw = (data.amount ?? data.importe ?? data.price ?? data.precio ?? data.valor);
            let importeNum = undefined;
            if (importeRaw !== undefined && importeRaw !== null && importeRaw !== "") {
              const n = Number(String(importeRaw).replace(",", "."));
              if (!isNaN(n)) importeNum = n;
            }

            const createdAtMs =
              Number(data.createdAtMs || 0) ||
              (toDateFromCreatedAt(data.createdAt)?.getTime() || 0);

            const destino = (data.destination || data.destino || data.numero || "").toString();

            return {
              tipo: "recarga",
              id: (d && d.id) ? d.id : (data.id || ""),
              numero: destino,
              productId: productIdNorm,
              importe: importeNum,
              createdAtMs: createdAtMs,
              fecha: formatFechaFromCreatedAt(data.createdAt),
              status: statusUp,
              estado: estado
            };
          });

          mapped.sort((a, b) => (sortKeyMovimiento(b) - sortKeyMovimiento(a)));
          return mapped.slice(0, 50);
        }

        function withTimeout(promise, ms) {
          return new Promise((resolve) => {
            let done = false;
            const t = setTimeout(() => {
              if (done) return;
              done = true;
              resolve(null);
            }, ms);

            Promise.resolve(promise)
              .then((v) => {
                if (done) return;
                done = true;
                clearTimeout(t);
                resolve(v);
              })
              .catch(() => {
                if (done) return;
                done = true;
                clearTimeout(t);
                resolve(null);
              });
          });
        }

        // ===== MODALES (NO se re-renderizan “en caliente”) =====
        const modalBg    = document.getElementById("modal-bg");
        const modalLista = document.getElementById("modal-lista");
        const modalTitulo= document.getElementById("modal-titulo");
        const cerrar     = document.getElementById("cerrarModal");
        const modalDlg   = modalBg ? modalBg.querySelector(".modal") : null;
        let lastFocusedElement = null;

        function abrirModalAccesible() {
          if (!modalBg) return;
          lastFocusedElement = document.activeElement;
          modalBg.style.display = "flex";
          const foco = cerrar || modalDlg;
          if (foco && typeof foco.focus === "function") {
            setTimeout(() => foco.focus(), 0);
          }
        }

        function cerrarModalAccesible() {
          if (modalBg) modalBg.style.display = "none";
          if (lastFocusedElement && typeof lastFocusedElement.focus === "function") {
            lastFocusedElement.focus();
          }
        }

        document.addEventListener("keydown", (e) => {
          if (e.key === "Escape" && modalBg && modalBg.style.display === "flex") {
            cerrarModalAccesible();
          }
        });

        function abrirModal(tipo, titulo) {
          if (!modalLista || !modalTitulo || !modalBg) return;

          modalTitulo.textContent = titulo;
          modalLista.innerHTML = "";

          const datos = lista.filter(m => m && m.tipo === tipo);
          datos.sort((a, b) => (sortKeyMovimiento(b) - sortKeyMovimiento(a)));

          if (!datos.length) {
            modalLista.innerHTML = '<div class="modal-item">Sin movimientos registrados</div>';
          } else {
            datos.forEach(m => {
              const importe = Number(m.importe);
              const signo   = tipo === "saldo" ? "+" : "-";
              const impTxt  = isNaN(importe) ? "" : `${signo}${importe.toFixed(2)} €`;

              let statusUp = (m && (m.status || m.estado) ? (m.status || m.estado) : "").toString().trim().toUpperCase();
              if (statusUp === "OK" || statusUp === "SUCCESS") statusUp = "COMPLETED";

              const parts = [];
              const ft = normalizeFechaText(m) || "";
              if (ft) parts.push(ft);
              if (impTxt) parts.push(impTxt);
              if (tipo === "recarga" && statusUp) {
                const label =
                  (statusUp === "COMPLETED") ? "Completada" :
                  (statusUp === "PENDING") ? "En proceso" :
                  (statusUp === "FAILED") ? "Fallida" :
                  (statusUp === "CANCELLED") ? "Cancelada" :
                  (statusUp === "REFUNDED") ? "Reembolsada" :
                  statusUp;
                parts.push(label);
              }

              const fila = document.createElement("div");
              fila.className = "modal-item";

              const partsEs = (Array.isArray(parts) ? parts : []).map((p) => {
                const s = (p == null) ? "" : String(p);
                const up = s.trim().toUpperCase();
                if (up === "COMPLETED") return "Completada";
                if (up === "PENDING") return "En proceso";
                if (up === "FAILED") return "Fallida";
                if (up === "CANCELLED" || up === "CANCELED") return "Cancelada";
                if (up === "REFUNDED") return "Reembolsada";
                return s;
              });

              fila.textContent = partsEs.join(" | ");
              // Traduce estados a ES si vienen como tokens canónicos
              try {
                const txt = (fila.textContent || "").toString();
                fila.textContent = txt
                  .replace(/\bCOMPLETED\b/g, "Completada")
                  .replace(/\bPENDING\b/g, "En proceso")
                  .replace(/\bFAILED\b/g, "Fallida")
                  .replace(/\bCANCELLED\b/g, "Cancelada")
                  .replace(/\bCANCELED\b/g, "Cancelada")
                  .replace(/\bREFUNDED\b/g, "Reembolsada");
              } catch (_) {}

              modalLista.appendChild(fila);
            });
          }

          abrirModalAccesible();
        }

        function abrirModalCorreos() {
          if (!modalLista || !modalTitulo || !modalBg) return;

          modalTitulo.textContent = "Historial de correos enviados";
          modalLista.innerHTML = "";

          const recargasLocal = lista.filter(m => m && m.tipo === "recarga");
          recargasLocal.sort((a, b) => (sortKeyMovimiento(b) - sortKeyMovimiento(a)));

          if (!recargasLocal.length) {
            modalLista.innerHTML = '<div class="modal-item">No hay correos enviados</div>';
          } else {
            recargasLocal.forEach(m => {
              const idTxt      = m.id || "Sin ID";
              const emailTxt   = (sessionEmailSnapshot || localStorage.getItem("usuario") || emailUsuarioBase || "Sin correo").toString();
              const importe    = Number(m.importe);
              const importeTxt = isNaN(importe) ? "" : `${importe.toFixed(2)} €`;
              const estadoBase = (m.estado || "").toString();
              const estadoTxt  = estadoBase === "OK" ? "Entregada" : "En proceso";

              const fila = document.createElement("div");
              fila.className = "modal-item";
              fila.textContent =
                `${normalizeFechaText(m) || ""} | ${emailTxt} | ${importeTxt} | ${m.numero || ""} | ${estadoTxt} | ID: ${idTxt}`;
              modalLista.appendChild(fila);
            });
          }

          abrirModalAccesible();
        }

        const cardRecarga = document.getElementById("card-recarga");
        const cardSaldo   = document.getElementById("card-saldo");
        const cardCorreo  = document.getElementById("card-correo");

        if (cardRecarga) {
          cardRecarga.onclick = () => abrirModal("recarga", "Historial de recargas");
          cardRecarga.addEventListener("keydown", (e) => {
            if (e.key === "Enter" || e.key === " ") {
              if (e.key === " ") e.preventDefault();
              abrirModal("recarga", "Historial de recargas");
            }
          });
        }

        if (cardSaldo) {
          cardSaldo.onclick = () => abrirModal("saldo", "Historial de saldos");
          cardSaldo.addEventListener("keydown", (e) => {
            if (e.key === "Enter" || e.key === " ") {
              if (e.key === " ") e.preventDefault();
              abrirModal("saldo", "Historial de saldos");
            }
          });
        }

        if (cardCorreo) {
          cardCorreo.onclick = () => abrirModalCorreos();
          cardCorreo.addEventListener("keydown", (e) => {
            if (e.key === "Enter" || e.key === " ") {
              if (e.key === " ") e.preventDefault();
              abrirModalCorreos();
            }
          });
        }

        if (cerrar && modalBg) {
          cerrar.onclick = () => cerrarModalAccesible();
          modalBg.onclick = e => e.target === modalBg && cerrarModalAccesible();
        }

        // ==============================
        // FIX: render único visible
        // - intentamos Firestore (rápido) con timeout
        // - luego un solo render + reveal (sin swaps)
        // - y sincronizamos sesión localStorage aquí (sin 2º listener)
        // ==============================
        try {
          const fbUser = await getFirebaseUserOnce(8000);

          if (fbUser && fbUser.email) {
            sessionEmailSnapshot = String(fbUser.email).toLowerCase();

            // Sync localStorage (antes estaba en el script final onAuthStateChanged)
            try {
              const raw = localStorage.getItem("usuarioRegistrado") || "{}";
              const datos = JSON.parse(raw);

              const nuevo = {
                ...(datos || {}),
                nombre: (datos && datos.nombre) || fbUser.displayName || "",
                email: sessionEmailSnapshot,
                activo: true
              };

              localStorage.setItem("usuarioRegistrado", JSON.stringify(nuevo));
              localStorage.setItem("usuario", sessionEmailSnapshot);
            } catch (e) {
              console.error("Error sincronizando sesión en historial:", e);
            }
          }

          if (fbUser && fbUser.uid) {
            const h = (location && location.hostname) ? location.hostname : "";
            const timeoutMs = (h === "127.0.0.1" || h === "localhost") ? 8000 : 1200;

            // 1) Leer recargas (fuente principal cuando existe: COMPLETED/REFUNDED)
            const fsRecargasMaybe = await withTimeout(fetchRecargasFromFirestore(fbUser.uid), timeoutMs);

            // 2) Leer orders (para PENDING/FAILED/CANCELLED que no crean /recargas)
            const fsOrdersMaybe = await withTimeout(fetchOrdersFromFirestore(fbUser.uid), timeoutMs);

            /* debug logs removed */

            // Index de estados por orderId (recargas > orders)
            const __statusByOrderId = Object.create(null);

            try {
              if (Array.isArray(fsOrdersMaybe)) {
                fsOrdersMaybe.forEach((o) => {
                  const k = (o && o.id) ? String(o.id) : "";
                  const s = (o && o.status) ? String(o.status).trim().toUpperCase() : "";
                  if (k && s) __statusByOrderId[k] = s;
                });
              }
              if (Array.isArray(fsRecargasMaybe)) {
                fsRecargasMaybe.forEach((r) => {
                  const k = (r && r.id) ? String(r.id) : "";
                  const s = (r && r.status) ? String(r.status).trim().toUpperCase() : "";
                  if (k && s) __statusByOrderId[k] = s; // override: recargas manda
                });
              }
            } catch (_) {}

            // Si ya existe un movimiento local con orderId, NO metas también el doc Firestore a lista.
            const __existingOrderIds = new Set();
            try {
              if (Array.isArray(lista)) {
                lista.forEach((m) => {
                  const oid = (m && (m.orderId || (m.extra && m.extra.orderId)))
                    ? String(m.orderId || (m.extra && m.extra.orderId))
                    : "";
                  if (oid) __existingOrderIds.add(oid);
                });
              }
            } catch (_) {}

            const fsRecargasForMerge = (Array.isArray(fsRecargasMaybe) ? fsRecargasMaybe : []).filter((r) => {
              const id = (r && r.id) ? String(r.id) : "";
              return id ? !__existingOrderIds.has(id) : true;
            });

            const fsOrdersForMerge = (Array.isArray(fsOrdersMaybe) ? fsOrdersMaybe : []).filter((o) => {
              const id = (o && o.id) ? String(o.id) : "";
              return id ? !__existingOrderIds.has(id) : true;
            });

            // Merge sin duplicados por id:
            // - Añade recargas/órdenes SOLO si no están ya representadas por un movimiento local con orderId.
            if (fsRecargasForMerge.length) {
              lista = mergeByIdPreferFirst(fsRecargasForMerge, lista);
            }
            if (fsOrdersForMerge.length) {
              lista = mergeByIdPreferFirst(lista, fsOrdersForMerge);
            }

            // Propaga estado real a movimientos locales que tengan orderId
            try {
              if (Array.isArray(lista)) {
                lista.forEach((m) => {
                  const oid = (m && (m.orderId || (m.extra && m.extra.orderId)))
                    ? String(m.orderId || (m.extra && m.extra.orderId))
                    : "";
                  if (!oid) return;

                  const st = __statusByOrderId[oid];
                  if (!st) return;

                  m.status = st;
                  m.estado = (st === "COMPLETED") ? "OK" : st;

                  if (m.extra && typeof m.extra === "object") {
                    m.extra.estado = st;
                    m.extra.status = st;
                  }
                });
              }
            } catch (_) {}
          }
        } catch (e) {
          console.error("Error preparando dataset Firestore:", e);
        }

        // ===== Monedas (SOLO COMPLETED) =====
        function isCompletedMovimiento(m) {
          const s = (m && m.status ? String(m.status) : "").trim().toUpperCase();
          const e = (m && m.estado ? String(m.estado) : "").trim().toUpperCase();
          return (s === "COMPLETED") || (e === "OK");
        }

        function isNautaMovimiento(m) {
          const pid = (m && m.productId ? String(m.productId) : "").toLowerCase();
          const dest = (m && m.numero ? String(m.numero) : "");
          return pid.includes("nauta") || dest.includes("@");
        }

        function coinsForMovimiento(m) {
          if (!m) return 0;
          if (!isCompletedMovimiento(m)) return 0;

          // Nauta: fijo
          if (isNautaMovimiento(m)) return 5;

          const imp = Number(m.importe);
          if (!Number.isFinite(imp)) return 0;

          if (imp >= 10 && imp < 20) return 13;
          if (imp >= 20 && imp < 30) return 27;
          if (imp >= 30 && imp < 50) return 41;
          if (imp >= 50) return 69;

          return 0;
        }

        function updateMonedasCardFromLista() {
          const elActual = document.getElementById("monedasActuales");
          const elTxt = document.getElementById("monedasProgresoTexto");
          const elBar = document.getElementById("barraProgresoInner");
          const btn = document.getElementById("btnCanje");

          if (!elActual || !elTxt || !elBar) return;

          const target = 999;
          const seen = new Set();
          let total = 0;

          (Array.isArray(lista) ? lista : []).forEach((m) => {
            if (!m || m.tipo !== "recarga") return;

            const key =
              (m.orderId || (m.extra && m.extra.orderId) || m.id || "").toString();
            if (key && seen.has(key)) return;
            if (key) seen.add(key);

            total += coinsForMovimiento(m);
          });

          elActual.textContent = String(total);
          elTxt.textContent = `${total} / ${target}`;

          const pct = Math.max(0, Math.min(100, (total / target) * 100));
          elBar.style.width = `${pct}%`;

          if (btn) {
            const activo = total >= target;
            btn.classList.toggle("activo", activo);
            btn.disabled = !activo;
            btn.setAttribute("aria-disabled", activo ? "false" : "true");

            // Click: canje manual vía soporte (solo si está activo)
            if (!btn.__rpcCanjeBound) {
              btn.__rpcCanjeBound = true;
              btn.addEventListener("click", () => {
                try {
                  // Revalida por seguridad
                  const txt = (document.getElementById("monedasActuales")?.textContent || "0").toString();
                  const n = Number(txt.replace(/[^\d]/g, "")) || 0;
                  if (n < target) return;

                  // Mensaje simple (sin automatizar recarga)
                  if (typeof showToastSuccess === "function") {
                    showToastSuccess("Canje disponible: contacta con soporte para recibir tu recarga gratis.");
                  } else {
                    alert("Canje disponible: contacta con soporte para recibir tu recarga gratis.");
                  }

                  // (Opcional) llevar a Cuenta como “hub” de soporte
                  setTimeout(() => {
                    try { window.location.href = "cuenta.html"; } catch (_) {}
                  }, 800);
                } catch (_) {}
              });
            }
          }
        }

        // Un solo render (ya con dataset final elegido) y reveal
        renderCardsFromLista(true);
        updateMonedasCardFromLista();
        revealHistorialOnce();
      })();
    });
  </script>

  <!-- Session sync moved into main init to avoid duplicate onAuthStateChanged listeners -->

  <script type="module" src="js/app.js?v=r1"></script>
</body>
</html>
